def apply_all_func(int_list, *functions):
    # В функции apply_all_func создайте пустой словарь results.
    results = {}
    for function in functions:
        # При переборе функций записывайте в словарь results результат работы
        # этой функции под ключом её названия.
        # results = {function.__name__: function(int_list)}
        # В этом случае при выполнении строки создаётся новый словарь,
        # в котором один ключ будет равен имени функции (function.__name__),
        # а значением будет результат вызова этой функции с аргументом int_list.
        # В результате, переменная results будет содержать новый словарь,
        # в который добавленных (или изменённых) пар ключ-значение не будет — это новое значение,
        # определяемое в момент выполнения этой строки.
        results[function.__name__] = function(int_list)
        # Здесь переменная results уже является существующим словарём.
        # В данном случае к этому словарю добавляется новая пара ключ-значение,
        # где ключ — это имя функции (function.__name__), а значение — результат вызова этой функции
        # с аргументом int_list. Таким образом, если ключ уже существует, его значение будет перезаписано.

        # Возвращать словарь, где ключом будет название вызванной функции,
        # а значением - её результат работы со списком int_list
    return results

# Запустите функцию apply_all_func, передав в неё список из чисел и набор других функций.

print(apply_all_func([6, 20, 15, 9], max, min))
print(apply_all_func([6, 20, 15, 9], len, sum, sorted))
print(apply_all_func([6, 20, 15, 9], zip, type))

print(apply_all_func([-11, 206, 95, 1856, 65], max, min))
print(apply_all_func([-11, 206, 95, 1856, 65], len, sum, sorted))
print(apply_all_func([-11, 206, 95, 1856, 65], zip, type))



# НЕ ЗАБЫТЬ ЭТО ВСЁ УЛОЖИТЬ В ГОЛОВЕ ПО ПОЛОЧКАМ.
